Here's an overview of my assumptions.  Please note: You will find other assumption notes peppered through my code.

All my endpoints are available at:
http://mpede.webfactional.com/{{ENDPOINT}}

I assume PHP 7.1 is fine.

I also provided my DB Schema in the secure/iugo_db.sql file.  I say "MySql", but I trust if you're using "MariaDB", you'll allow me to use them interchangeably.

General:
About errors: if there's a DB Error, then displaying that in the specified error format is preferred.  There didn't seem to be a need to reinterpret or obscure exceptions thrown rightfully by the application.

When you're passing in an INTEGER in JSON, I assume it will NOT be a STRING.
This is valid:
{
	"UserId": 2
}
This is NOT:
{
	"UserId": "2"
}
The second will result in a validation failure.  The specifications reference valid JSON, and your examples show you know better.  If your tests throw in strings where there are numbers, I don't do any implicit type conversion and validation.  If you want that, I assume it would be in the specification and it is not.

1) Timestamp

Seemed pretty straight-forward to me.  I used this as an opportunity to set up my security model in controller, and a manager in the secure folder.

2) Transaction Recording

I assume that if the transaction is not verified, then you want no logging of it at all.
I also assume that just because you specify INTEGER, that FLOAT is also valid.  When dealing with currency, decimals are the norm.  I allow any float value, but precision of 2 could easily be enforced.
If your currency is all pennies, then I'll give you that integers are sufficient.
If all you test is with Integers, then your tests will be successful, but Floating point numbers will not break things and don't need to be encoded as strings.  In fact, DO NOT encode Floats as Strings.

3) Transaction Data Querying

I assume you only want a count of Valid Transactions.  This follows from my assumption in 2).

At this point in my programming, I started using POSTMAN. A Chrome Plugin.  It allows you to POST JSON to a URL.  If you're wondering why I didn't add some testing Javascript, it's because it was completely unnecessary.  That's what tools are for, am I right?

4) Leaderboard Score Posting

I assume that when you're determining rank, that tie scores have equal rank, but 3rd is still 3rd, even if there's a 2-way tie for 1st.

I assume you want fast reads, and that writes can take a little longer to calculate the rankings for everyone in the leaderboard.  It also makes pagination with rankings trivial if they're precalculated.

5) Leaderboard Get

I Assume that when you ask for the complete ranking, that the order of ties is irrelevant.  If there's two or more people with the same rank, you don't care what order they're in.
Right now, they display in whatever order SQL spits them back at.  If you want it to be more consistent, then specify userId, the Time they recorded the score or something.  All depending, I would need to modify the Database to accommodate (in case of added field like timestamp).

I also assume that if you look for a UserId that's not in the Leaderboard, that I should just throw an error.  I could have continued with the leaderboard query, but I felt that if a User wasn't in the leaderboard, then they shouldn't see the results.

6) User Save

I assume that whatever comes in on as User JSON Data to save can fit inside a LONGTEXT of MySql.
When dealing with arrays, I assume you want the new array taken over the old one, not merged.

I also assumed that there would not be any multi-part FORM data.  I would put this under General, but this is the only endpoint it pertains to.  I always assume that:
file_get_contents('php://input')
Will get me all the JSON Data I want.

I assume you wanted it stored as JSON, for easy retrieval, but if you wanted a B-Tree implementation, I would be happy to do that as well.
A B-Tree would allow for searchable user data.

7) User Load
I assume that if you've saved any String data that has slashes in it, that you're fine with them being removed.
I put in rudimentary SQL injection prevention, so slashes are a no-no.

BONUS)
I made the Database Reset endpoint at:
http://{{hostname}}/DBTableReset

I made it take a Verifier that uses the Secret Key you already provided.
The Verifier is a SHA1 of the Secret Key, Table Name 1, Table Name 2, ...

Here are the verifier JSON strings you will need to test:
{"TableNames":"ALL","Verifier":"a886c01529cb2d8497600269cc233857d14d4434"}
{"TableNames":["leaderboard"],"Verifier":"2935c2b6226b9942f92bc2845c5a1c5b9a17a54a"}
{"TableNames":["transaction"],"Verifier":"98f90a89618b4376aeabe13afc84a3913a9417a7"}
{"TableNames":["userdata"],"Verifier":"7d45c1a9f9c3c2fe85e02a0ad4ea9d172a456896"}

I assume that anyone with the Secret key will not try and do anything untoward, and can delete any table they want, even if it's outside the three specified above.  Having the key assumes root level access and responsibility.

If I had more time:

I would revisit the Documentation of the functions in all the files.  I could also document more test cases.
More testing.  As a rule, it never hurts.

I Would do that B-Tree implementation for fun.

Making things Verifiable as a mandatory part of the managers.  Everything should need some form of verification!
This is last because it definitely defies the specification.  I'd LIKE to do it, but any implementation would cause all your tests to fail outside of adding Transactions.